---
title: "HDBSCAN with the dbscan package"
author: "Michael Hahsler, Matt Piekenbrock"
output:
  html_notebook: default
  pdf_document: default
header-includes: \usepackage{animate}
---
The dbscan package comes with 
```{r}
library("dbscan")
data("moons")
plot(moons, pch=20, xlab="X", ylab="Y")
```

By default, HDBSCAN returns a flat clustering of the most salient or 'stable' clusters

```{r}
  cl <- dbscan::hdbscan(moons, minPts = 5)
  cl
  
  all_info <- attr(cl, ".info")
  cl_hier <- attr(all_info, "cl_hierarchy")
  dbscan:::node_xy(cl_hier)
  
  dend <- dbscan:::buildCondensedTree(all_info)
  dendextend::get_nodes_xy(dend)
  minPts <- 5
  x <- moons
  ## Calculate Core distance using kNN
  euc_dist <- dist(x, method = "euclidean")
  core_dist <- kNNdist(x, k = minPts - 1)[, minPts - 1]
  n <- nrow(x)

  ## Mutual Reachability matrix
  mrd <- dbscan:::mrd(euc_dist, core_dist)

  ## Get MST, convert to RSL representation
  mst <- dbscan:::prims(mrd, n)
  hcl <- dbscan:::hclustMergeOrder(mst, order(mst[, 3]))

  ## Process the hierarchy to retrieve all the necessary info needed by HDBSCAN
  res <- dbscan:::hdbscan_fast(hcl, minPts)
  dend <- dbscan:::buildCondensedTree(res)
  dendextend::get_nodes_xy(dend)

  dbscan:::node_xy(attr(res, "cl_hierarchy"))

  t1 <- dbscan:::buildDendrogram(cl$hcl)
  t2 <- stats:::as.dendrogram(cl$hcl)
```
The 'flat' results are stored in the 'cluster' member. Noise points are given a value of 0. 
```{r}
 plot(moons, col=cl$cluster+1, pch=20)
```

## Robust Single Linkage 
The Robust Single Linkage (RSL) tree is stored as a dendrogram in the 'rsl_tree' member.

```{r}
plot(cl$rsl_tree)
```

## Validation 1: DBSCAN* vs RSL tree cutting
```{r}
cuts <- unname(dendextend::cutree(cl$hcl, h=0.25))
cuts[which(!cuts %in% which(table(cuts) > 1))] <- 0 # minPts doesn't matter? 
cut_cl <- match(cuts, unique(cuts)) - 1 # 'Normalize' so cluster ID increments
table(cut_cl)
```
```{r}
dbscan_cl <- dbscan::dbscan(x_test1, eps=0.25, minPts = 5, borderPoints = F)
table(dbscan_cl$cluster)
```
```{r}
  all.equal(dbscan_cl$cluster, cut_cl)
```

## Validation 2: DBSCAN* vs RSL tree cutting at all MST distance values 
```{r}
check <- rep(F, nrow(cl$mst))
for (eps_i in 1:nrow(cl$mst)) {
  eps <- cl$mst[eps_i, 3]
  
  ## Cutting the robust single linkage tree 
  cut_tree <- function(hcl, eps){
    cuts <- unname(cutree(hcl, h=eps))
    cuts[which(diag(mrd) > eps)] <- 0 # Use core distance to distinguish noise
    cut_cl <- match(cuts, sort(unique(cuts))) - 1 # 'Normalize' so cluster ID increments; sort ensures noise is 0
    cut_cl
  }
  
  ## RSL cut 
  cut_cl <- cut_tree(eps+.Machine$double.eps)
  
  ## DBSCAN
  dbscan_cl <- dbscan::dbscan(x_test1, eps=eps+.Machine$double.eps, minPts = 5, borderPoints = F)
  
  ## Use run length encoding as an ID-independent way to check ordering
  res <- all.equal(rle(cut_cl)$lengths, rle(dbscan_cl$cluster)$lengths)
  
  ## Simple Check 
  check[eps_i] <- (res == "TRUE")
}
print(all(check == T))
```

## Condensed Tree
```{r}
 plot(cl)
```

You can change up colors
```{r}
 plot(cl, gradient = c("yellow", "orange", "red", "blue"))
```

You can also scale the widths for individual devices appropriately 
```{r}
plot(cl, gradient = c("purple", "blue", "green", "yellow"), scale=25)
```

And outline the ones that were used in the flat solution 
```{r}
plot(cl, gradient = c("purple", "blue", "green", "yellow"), show_flat = T)
```

## Cluster Stability Scores
Note the stability scores correspond to the labels on the condensed tree, but the cluster assignments in the cluster member element does not correspond to the labels in the condensed tree. Also note that these scores represent the stability scores _before_ the traversal up the tree that updates the scores based on the children. 
```{r}
print(cl$cluster_scores)
```

The individual point membership 'probabilities' are in the probabilities member element
```{r}
  print(cl$membership_prob)
```

These can be used to show the 'degree of cluster membership' through, for example, plotting points with transparencies that correspond to their membership degrees.   
```{r}
  plot(moons, col=cl$cluster+1, pch=21)
  colors <- sapply(1:length(cl$cluster), function(i) adjustcolor(palette()[(cl$cluster+1)[i]], alpha.f = cl$membership_prob[i]))
  points(moons, col=colors, pch=20)
```

## Hierarchical representations
The hierarchy of cluster membership changes and the distance values that happened at, for what its worth, as shown in Table 1 of [1], can be generated via the as.matrix S3 method.
```{r}
  hdbscan_hier <- as.matrix(cl)
  head(hdbscan_hier)[, seq(1, ncol(hdbscan_hier), by=10)]
```

## Validating HDBSCAN

HDBSCAN is equivalent to running DBSCAN* at $n$-1 values of epsilon such that each epsilon produces a distinct clustering result. There are infinitely many possible values of eps at which that happens. One easy way of getting a set of values is to extract the minimal possible values such that any values below such values produces a different clustering. These values, luckily, can be computed via a minimum spanning tree algorithm. First, the mutual reachability graph needs to be computed as it is mutual reachability distance that the MST is be computed over. 
```{r}
  minPts <- 5
  moon_dist <- dist(moons, method = "euclidean")
  core_dist <- kNNdist(moons, k = minPts - 1)[, minPts - 1]
  mrg <- dbscan:::mrd(moon_dist, cd = core_dist)
```

Then, the MST can be computed using any number of algorithms. The dbscan package uses an efficient version of Prim's algorithm. 
```{r}
  mst <- dbscan:::prims(mrg, nrow(moons))
```

```{r}
  eps_vals <- sort(mst[, 3], decreasing = T) + .Machine$double.eps ## For consistency 
  dbscan_res <- list()  
  for (i in 1:length(eps_vals)){
    dbscan_res[[i]] <- dbscan::dbscan(moons, eps = eps_vals[i], minPts = minPts, borderPoints = F)
  }
  
```




## How HDBSCAN Works 
Per the name, HDBSCAN is an algorithm that computes a hierarchy of (DBSCAN) clusters. (more explanation coming soon)
```{r, fig.show=TRUE, echo=FALSE}
oopt = ani.options(interval = 0.20, nmax = length(hclust_info$height)) 
last_eps_values <- rep(max(hclust_info$height), length(hclust_info$height)+1)
saveGIF({
  for (eps in sort(hclust_info$height, decreasing = T)){
    model <- dbscan::dbscan(x_test1, eps=eps+.Machine$double.eps, minPts = 5, borderPoints = F)
    which_to_not_update <- which(model$cluster == 0) 
    pt_type <- rep(20, length(model$cluster))
    pt_type[which_to_not_update] <- 8
    plot(x_test1, col=model$cluster+1, pch=pt_type)
    last_eps_values[-which_to_not_update] <- eps
    symbols(x_test1[, 1], x_test1[, 2], 
            circles = last_eps_values, fg="black", add=T, lwd=0.15)#, lty=3)
  }
}, movie.name = "hdbscan_pts.gif", ani.width = 600, ani.height = 600)
```


## Clustering Examples 
Using the Iris data set 
```{r}
data(iris)
iris <- as.matrix(iris[,1:4])
dbscan::hdbscan(iris)
```

```{r}
data("blobs")
cl2 <- dbscan::hdbscan(blobs, minPts = 15, gen_condensed_tree = T)
```


```{r}
plot(cl2$condensed_tree)
```


```{r}
plot(x_test2, col=cl2$cluster+1, pch=20)
```

The different opacities corresponding to membership probabilities can also be viewed.  
```{r}
  plot(x_test2, col=cl2$cluster+1, 
       pch=ifelse(cl2$cluster == 0, 8, 1), # Mark noise as star
       cex=ifelse(cl2$cluster == 0, 0.5, 0.75), # Decrease size of noise
       xlab=NA, ylab=NA)
  colors <- sapply(1:length(cl2$cluster), 
                   function(i) adjustcolor(palette()[(cl2$cluster+1)[i]], alpha.f = cl2$membership_prob[i]))
  points(x_test2, col=colors, pch=20)
```
```{r}
  plot(cl2)
```



## Performance 
All of the computational and memory intensive tasks required by HDSBCAN were written in C++ using the Rcpp package. With DBSCAN, the performance depends on the parameter settings, primarily on the radius at which points are considered as candidates for clustering ('eps'), and generally less so on minPts. Larger values of eps increase the computation time. 
```{r}
  ## eps_vals == 4 increasing percentiles of neighbor sizes
  eps_vals <- quantile(as.vector(dist(x_test2)))[2:5]
  microbenchmark::microbenchmark(dbscan::dbscan(x_test2, eps = eps_vals[1], minPts = 15), times=15)
  microbenchmark::microbenchmark(dbscan::dbscan(x_test2, eps = eps_vals[2], minPts = 15), times=15)
  microbenchmark::microbenchmark(dbscan::dbscan(x_test2, eps = eps_vals[3], minPts = 15), times=15)
  microbenchmark::microbenchmark(dbscan::dbscan(x_test2, eps = eps_vals[4], minPts = 15), times=15)
```
HDBSCAN requires information that would normally be accessible by running DBSCAN at every 'eps' value that creates a unique clustering by DBSCAN. Since there are $n$ - 1 of these clusterings, where $n$ is the length of the data set, a naÃ¯ve approach might therefore be to run DBSCAN at each of these eps values, recording the information at each value. As one might expect, this would lead to extremely inefficient performance for large data sets! Even though all of this information is necessary for HDBSCAN to run, there are clever tricks used to improve the efficiency of HDBSCAN to a 'reasonable' level
```{r}
  microbenchmark::microbenchmark(dbscan::hdbscan(x_test2, minPts = 15), times = 15)
  microbenchmark::microbenchmark(dbscan::dbscan(x_test2, eps = eps_vals[4], minPts = 15), times = 15)
```
One of the primary computational bottleneck with using HDBSCAN is the computation of the full (euclidean) pairwise distance between all points, for which HDBSCAN currently relies on base R 'dist' method for. If a precomputed one is available, the running time of HDBSCAN can be reduced. 
```{r}
  microbenchmark::microbenchmark(dbscan::hdbscan(blobs, minPts = 15), times = 15)
  dblobs <- dist(blobs)
  microbenchmark::microbenchmark(dbscan::hdbscan(blobs, xdist = dblobs, minPts = 15), times = 15)
```
Generally speaking, the larger the data set, the more likely the 'dist' method will dominate the calculation. 

## HDBSCAN Internals 
There are several minor computational tasks that take up a significant enough part of the computation to have been considered for optimization. Below are several benchmarks for what has recently been improved. 

The MST computation
```{r}
  microbenchmark::microbenchmark(vegan::spantree(dblobs), times = 1000)
  microbenchmark::microbenchmark(dbscan:::prims(dblobs, attr(dblobs, "Size")), times = 1000)
```
The results are the same
```{r}
  mst_vegan <- vegan::spantree(dblobs)
  mst_dbscan <- dbscan:::prims(dblobs, attr(dblobs, "Size"))
  sum(mst_vegan$dist) == sum(mst_dbscan[, 3])
```

The conversion from the MST to the information provided by 'hclust' objects 
```{r}
  microbenchmark::microbenchmark(as.hclust(mst_vegan))
  microbenchmark::microbenchmark(dbscan:::hclustMergeOrder(mst_dbscan, o = order(mst_dbscan[, 3])))
```
There are optional computations that, by default, are not computed by HDSBCAN. This includes the explicit computation of the RSL dendrogram. Nonetheless, optimized code for this is available. 
```{r}
  hcl_vegan <- vegan:::as.hclust.spantree(mst_vegan)
  hcl_dbscan <- dbscan:::hclustMergeOrder(mst_dbscan, o = order(mst_dbscan[, 3]))
  microbenchmark::microbenchmark(as.dendrogram(hcl_vegan)) # stats S3 method 
  microbenchmark::microbenchmark(dbscan:::buildDendrogram(hcl_dbscan))
```
```{r}
  stats_dend <- as.dendrogram(hcl_vegan)
  dbscan_dend <- dbscan:::buildDendrogram(hcl_dbscan)
```
Of course, the two produce the same dendrogram 
```{r}
# Smaller data set due to time all.equal takes
stats_dend <- as.dendrogram(as.hclust(vegan::spantree(dist(moons))))
mst <- dbscan:::prims(dist(moons), nrow(moons))
dbscan_dend <- dbscan:::buildDendrogram(dbscan:::hclustMergeOrder(mst, o = order(mst[, 3])))
all.equal(stats_dend, dbscan_dend, use.names=T) # use.name since order of attributes may not match 
```

Finally, the primary method at which all the information needed by HDBSCAN is the "hdbscan_fast" method. It's been greatly improved with each passing version in both memory and computational efficiency. 
```{r}
  minPts <- 15
  microbenchmark::microbenchmark(dbscan:::hdbscan_fast(hcl, minPts))
```




```{r}


cl2 <- dbscan::hdbscan(blobs, minPts = 15, gen_condensed_tree = T)

plot(blobs[attr(cl2, "hdbscan")$`5`$contains,], pch=20, cex=0.5)
points(blobs[attr(cl2, "hdbscan")$`11`$contains,], pch=20, cex=0.5, col="red")
symbols(x = blobs[attr(cl2, "hdbscan")$`11`$contains,], circles = attr(cl2, "hdbscan")$`11`$eps, add=T, inches = F)


dbscan::dbscan(blobs[attr(cl2, "hdbscan")$`5`$contains,], borderPoints = T, minPts = 15, eps = eps_test[1] + .Machine$double.eps)
```

